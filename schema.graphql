type ExampleEntity @entity {
  id: ID!
  count: BigInt!
  tokenId: BigInt! # uint256
  offerAmount: BigInt! # uint256
}
type Approval @entity {
  id: ID!
  owner: Bytes! # address
  approved: Bytes! # address
  tokenId: BigInt! # uint256
}

type ApprovalForAll @entity {
  id: ID!
  owner: Bytes! # address
  operator: Bytes! # address
  approved: Boolean! # bool
}

type RedeemVoucher @entity {
  id: ID!
  signer: Bytes! # address
  tokenId: BigInt! # uint256
  redeemer: Bytes! # address
}

type RoleAdminChanged @entity {
  id: ID!
  role: Bytes! # bytes32
  previousAdminRole: Bytes! # bytes32
  newAdminRole: Bytes! # bytes32
}

type RoleGranted @entity {
  id: ID!
  role: Bytes! # bytes32
  account: Bytes! # address
  sender: Bytes! # address
}

type RoleRevoked @entity {
  id: ID!
  role: Bytes! # bytes32
  account: Bytes! # address
  sender: Bytes! # address
}

type Transfer @entity {
  id: ID!
  from: Bytes! # address
  to: Bytes! # address
  tokenId: BigInt! # uint256
}

# all entity for market place
type ReceivedCalled @entity {
  id: ID!
  buyer: Bytes! #address of person who send many accidentally
  amount: BigInt! # uint256
}
type FallbackCalled @entity {
  id: ID!
  buyer: Bytes! #address of person who send many accidentally
  amount: BigInt! # uint256
}
type CreateOffer @entity {
  id: ID!
  tokenId: BigInt! # uint256
  contractAddress: Bytes! #address
  offerAmount: BigInt! # uint256
  totalOffers: BigInt! # uint256
  startAt: BigInt! # uint256
  expiresAt: BigInt! # uint256
  offerBy: User! #address
  status: State! # uint256
}
type AcceptOffer @entity {
  id: ID!
  tokenId: BigInt! # uint256
  owner: User! #address
  contractAddress: Bytes! #address
  offerAmount: BigInt! # uint256
  offerBy: Bytes! #address
  status: State! # uint256
}
type RejectOffer @entity {
  id: ID!
  tokenId: BigInt! # uint256
  owner: User! #address
  contractAddress: Bytes! #address
  offerAmount: BigInt! # uint256
  offerBy: Bytes! #address
  status: State! # uint256
}
type WithDrawFromOffer @entity {
  id: ID!
  tokenId: BigInt! # uint256
  contractAddress: Bytes!
  offerAmount: BigInt! # uint256
  offerBy: Bytes! #address
}
type WithDrawAmount @entity {
  id: ID!
  offerAmount: BigInt! # uint256
  offerBy: Bytes! #address
}
type WithDrawRefundAmount @entity {
  id: ID!
  amount: BigInt! # uint256
  offerBy: Bytes! #address
}
type BuyNFT @entity {
  id: ID!
  tokenId: BigInt! # uint256
  owner: Bytes! #address
  contractAddress: Bytes! #address
  offerAmount: BigInt! # uint256
  offerBy: Bytes! #address
  ownerNFTId: NFTOwne!
}
type MarketItemCreated @entity {
  id: ID!
  tokenId: BigInt! # uint256
  contractAddress: Bytes! #address
  seller: User! #address
  buyer: Bytes! #address
  minPrice: BigInt! # uint256
  maxPrice: BigInt! # uint256
  isFixedPrice: Boolean #bool
  startAt: BigInt! # uint256
  expiresAt: BigInt! # uint256
  state: OfferState! # uint256
}
type MarketItemDelete @entity {
  id: ID!
  tokenId: BigInt! # uint256
  contractAddress: Bytes! #address
  seller: Bytes! #address
  state: OfferState! # uint256
}

type NFTOwne @entity {
  id: ID!
  tokenId: User! # string
  buyId: [BuyNFT!]! @derivedFrom(field: "ownerNFTId") #address
  status: Boolean! # uint256
}

type User @entity {
  id: ID!
  userAddress: Bytes! #address
  nftOwne: [NFTOwne!] @derivedFrom(field: "tokenId") #address
  acceptOffer: [AcceptOffer!] @derivedFrom(field: "owner") #address
  rejectOffer: [RejectOffer!] @derivedFrom(field: "owner") #address
  createOffer: [CreateOffer!] @derivedFrom(field: "offerBy") #address
  marketItemCreated: [MarketItemCreated!] @derivedFrom(field: "seller") #address  #address
}

enum State @entity {
  Created
  Release
  Inactive
}
enum OfferState @entity {
  OPEN
  CLOSE
}
